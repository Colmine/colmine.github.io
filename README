****************
* Project #1: Cache
* Class: CS321 Fall2019
* Date: 09/13/2019
* Cole Gilmore
**************** 

OVERVIEW:

Reads in data from a given text file and stores the strings in a virtual
cache system. Keeps track of the number of accesses to the virtual cache
as well as the number of times something is not found in the cache, a miss.
Removes data from the cache if it is at capacity to fit some new element.


INCLUDED FILES:

Cache.java - source file, contains all the methods used by the Cache class
CacheSimulator.java - driver class, contains main method for reading a file

README - this file


COMPILING AND RUNNING:

 From the directory containing all source files, compile the
 driver class (and all dependencies) with the command:
 $ javac Cache.java CacheSimulator.java
 OR
 $ javac *.java

 Run the compiled class file with the command:
 $ java CacheSimulator [1 | 2] [L1 cache size] [ | L2 cache size] [filename]

 Console output will give the results after the program finishes.


PROGRAM DESIGN AND IMPORTANT CONCEPTS:

Cache.java
 General organization of the methods contained in Cache.java follows the format
 of the interface in ICache.java. As this uses a Double Linked List to keep track
 of elements within the cache the methods rely on for() loops to look through
 the contents to see if the desired target is in the cache. If it's not,
 depending on the command used, it will remove the oldest/least used data element
 from the cache to fit in the new data element. The cache also uses generics to
 allow for any kind of data type to be used with the cache. The main reason why
 the constructors are setup the way they are is because I misread the requirements
 for the assignment, and while the majority of it still functions the same as a
 cache should, there are issues still contained in the class when trying to function
 as the assignment guidelines require.

CacheSimulator.java
Driver class for Cache.java, takes in arguments from the command line, and a file name, 
to read in; then starts putting data from the file into the virtual cache and removing old
data from the cache as needed. Uses scanners to do the majority of the parsing of
information. 

ICache.java (NOT INCLUDED BUT STILL NEEDS)
Interface class for Cache.java that provides most of the explanation of the methods
contained in Cache.java. Vital for using Cache.java and CacheSimulator.java as neither
will function without it. Provides the methods that Cache.java implements.


Overall
Lots of things could be improved in the Cache.java class as well as the CacheSimulator.java
class. This is mainly due to my procrastination and lack of proper understanding of
what the assignment was actually asking for. Specifically how the miss rate, hit rate,
and get functions work in Cache.java. All of them are messy and not 100% properly implemented
to the design specifications.

TESTING:

The testing of my program was mainly done by running the TestNG.xml files, specifically
cache.xml, and running small.txt on MobaXTerm. For the most part my program can handle
bad inputs, but it is by no means idiot proof at this current time. The known issues
in the program are the getHitRate(), getMissRate() and get() methods are essentially
broken if you try and setup Cache.java the way it was supposed to be. The get() method
runs into issues with actually adding in elements after the cache has been mostly filled,
and getHitRate() and getMissRate() are accurate results for about half of the tests done.

DISCUSSION:
 
I think the main issues I encountered during development was my own procrastination.
I had thought that I could get this project done in about 2 days, the time crunch was the 
biggest issue for me because I haven't had to think in the same mindset as a programmer
for about 2 months now. So most of that first day was spent just figuring out how to 
think about the problems and how to fix them. I think the next issue was that I didn't
properly understand the design specifications as my cache isn't properly implemented 
based on what the outline on the website tells us. Aside from those major issues the
only real bugs I ran into was getting my get() and remove() methods to work, as I kept
running into errors of NoSuchElementException or null pointers. These were the most
time consuming bugs to fix as I didn't really understand how to use the debugger with
the TestNG suite until a couple of hours ago. Turns out that I had been trying to
compare a DLLNode<T> data type to the T data/target type, which my code just skipped over
because of course they're not equal. What I've learned is that I should never procrastinate
this class's work, and that it's better to just chip away at it everyday rather than
leave it to the last minute.
